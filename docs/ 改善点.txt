1. ファイル受取	HTTP POST	サーバー「受け取ったよ！Job IDは 123 です」
2. OCR開始	WebSocket	{"status": "OCR", "msg": "文字を解析中...", "progress": 30}
3. AI推論開始	WebSocket	{"status": "AI", "msg": "勘定科目を推論中...", "progress": 70}
4. 完了報告	WebSocket	{"status": "DONE", "msg": "解析完了", "progress": 100, "result": {...}}→フロント側は内容カードの下には承認と修正ボタン/リンクが必要
5.OCRから戻ったデータとAIから解析したデータはそれぞれInvoiceに登録する必要です。既存ocr_resultカラムと新規ai_result
参考：/Users/junjietang/Projects/ai-business-automation/apps/web/prisma/schema.prisma
6.main.pyの初回AI挨拶メッセージと１のPost返信に分ける必要であれば、タイプを用意してください。
main.pyから返却データ構造はできれば統一してください。フロント側は判断しやすい
type Message = {
  id: string;
  role: 'user' | 'ai';
  type: 'text' | 'invoice_card'; // ここで種類を分ける
  content?: string;              // テキスト用
  invoiceData?: any;             // カード用（Pythonから返ってきたJSON）
  suggestions?: string[];        // 初回のサジェスト用
};
7.複数ファイル同時送信時のUI管理 (Front-end side)
ユーザーが3枚のファイルを一気に投げた場合、フロントエンド（Next.js）では**「Job IDごとに進捗バーを分ける」**管理が必要です。
// イメージ：実行中のジョブだけを管理するState
const [activeJobs, setActiveJobs] = useState<{id: string, progress: number, name: string}[]>([]);
動的な追加と削除: 解析が始まったら配列に job を追加し、WebSocketで DONE が来たら配列から削除して、チャット欄に「最終的なカード」をレンダリングします。
8. まとめ：複数ユーザー・複数ファイル時の設計原則
WebSocket URLにIDを含める: ws://api.example.com/ws/{job_id}
バックエンドは async 必須: AzureのAPIを待っている間に他の処理を止めない。
DBを中間地点にする: 前回お話しした通り、OCR結果などをDBに保存しておくことで、万が一WebSocketが瞬断しても、Job IDを使って後から結果を再取得（ポーリング）できます。
