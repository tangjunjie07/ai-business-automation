# 開発プラットフォーム選定

作成日: 2026-01-10

この文書は、要件（AI経理自動化・経営分析システム）を踏まえ、Web初期実装と将来のモバイル対応を容易にするための開発プラットフォーム推奨をまとめる。

## 目的
- Webを最初の提供プラットフォームとし、将来的にモバイルアプリ（iOS/Android）を容易に追加できることを最優先要件とする。

## フロントエンド（Web）
- 推奨: Next.js (TypeScript)
  - 理由: React エコシステムで高い再利用性、SSR による初期描画の速さ、型安全。
  - UI: Material-UI (MUI) を推奨（エンタープライズ向け一貫性）。
  - 状態管理/データ取得: Zustand / TanStack Query。

## モバイル戦略
- 推奨: React Native + Expo（または React Native CLI）
  - 理由: Next.js（React）と同一のコンポーネント/ロジック資産を共有しやすく、開発速度と保守性が向上するため。
  - モノレポ: Turborepo または Nx を使用し、Web と Mobile の共有パッケージ（UIコンポーネント、型、ユーティリティ）を管理。
  - 代替: Flutter（高パフォーマンス）の採用も検討可だが、React資産再利用を優先する場合は不利。

## バックエンド
- 推奨: FastAPI (Python 3.11+)
  - 理由: 非同期処理、Pydantic による型検証、データ処理ライブラリ（Pandas, scikit-learn）との親和性。
  - マイクロサービス構成: Document Ingestion / OCR/AI / Reconciliation / Accounting / Payment / Anomaly / Reporting。
  - 決済振込実行サービスは分離（Payment Execution Service）し、Node.js (Express) を選択可（銀行API SDKや既存エコシステムとの相性を考慮）。

## OCR / AI
- 推奨: Azure Document Intelligence（Prebuilt Invoice + カスタム学習）
  - 補助: Azure OpenAI / LangChain を用いた曖昧推論・手書き補完。

## データ基盤
- DB: PostgreSQL（Row Level Security を用いたマルチテナント）
- キャッシュ: Redis（セッション、レート制御）
- ストレージ: Azure Blob Storage または S3（請求書原本保存）

## 非同期 / メッセージング
- Kafka（高スループット）または RabbitMQ（運用容易）
- タスクキュー: Celery（Python）

## インフラ
- 優先クラウド: Microsoft Azure（OCR/AIの親和性から推奨）
  - コンテナ: AKS（Kubernetes）
  - DB: Azure Database for PostgreSQL
  - シークレット: Azure Key Vault

## CI/CD・テスト
- CI: GitHub Actions
- E2E: Playwright
- モバイル: Expo EAS（ビルド、配布）

## セキュリティ要件（必須）
- 認証: OAuth2 / OpenID Connect（Azure AD B2C または Auth0）
- RBAC、MFA（振込承認時必須）
- TLS 1.3、保存データは AES-256、監査ログ保持（7年）

## RLS（Row Level Security）実装補足
### 概要
PostgreSQLのRLSを全テーブルに適用することで、アプリ側のミス（WHERE句の書き漏れ等）によるテナント間データ漏洩を防止します。以下は運用上の推奨事項とSQL例です。

### 必須拡張と初期設定
```
-- UUID生成拡張
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- テナントテーブル例
CREATE TABLE tenants (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  country_code CHAR(2) NOT NULL
);
```

### invoices テーブルとRLSポリシー例
```
CREATE TABLE invoices (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id UUID REFERENCES tenants(id),
  project_id UUID,
  vendor_name TEXT,
  amount DECIMAL(15,2),
  currency CHAR(3),
  status TEXT DEFAULT 'pending'
);

-- RLS 有効化
ALTER TABLE invoices ENABLE ROW LEVEL SECURITY;

-- セレクト・インサート・アップデートポリシー
CREATE POLICY tenant_select ON invoices
  FOR SELECT USING (tenant_id = current_setting('app.current_tenant_id')::UUID);

CREATE POLICY tenant_insert ON invoices
  FOR INSERT WITH CHECK (tenant_id = current_setting('app.current_tenant_id')::UUID);

CREATE POLICY tenant_update ON invoices
  FOR UPDATE USING (tenant_id = current_setting('app.current_tenant_id')::UUID)
              WITH CHECK (tenant_id = current_setting('app.current_tenant_id')::UUID);

-- 権限の見直し
REVOKE ALL ON invoices FROM PUBLIC;

-- インデックス（性能）
CREATE INDEX idx_invoices_tenant_id ON invoices(tenant_id);
```

### 運用注意点
- アプリケーションはDB接続時、必ずセッション変数を設定する必要があります（例:`SELECT set_config('app.current_tenant_id', '<UUID>', false);`）。
- トランザクション単位での安全設定には `SET LOCAL` を利用するパターンを推奨します。
- 他の主要テーブル（`OCRResult`, `Reconciliation`, `JournalEntry`, `PaymentOrder`）にも同様のRLSを適用してください。
- 監査のために `audit` テーブルやログ収集を整備し、誰がいつテナントを切り替えたかを追跡可能にします。

## アプリ（FastAPI）側ミドルウェアの注意
- FastAPIなどのバックエンドはDB接続確立後、リクエストコンテキストから `tenant_id` を取得して `set_config` を実行するミドルウェアを必ず入れてください。簡易例（擬似コード）:

```python
async def db_tenant_middleware(request, call_next):
    tenant_id = extract_tenant_from_token(request)
    async with db.connection() as conn:
        await conn.execute("SELECT set_config('app.current_tenant_id', $1, false);", (str(tenant_id),))
        response = await call_next(request)
    return response
```

## Monorepo／共有コード 補足
- `packages/types/` の型は手動で二重管理せず、自動生成フロー（OpenAPI→TypeScript、Pydanticモデル生成など）を導入してください。
- 共有UIコンポーネントは可能な限り `ui-components/` に置き、WebとMobileで使用可能な実装（`react-native-web` 対応）を優先します。
- CIでの変更影響範囲判定（turborepo の `affected` 戦略等）を導入するとビルドコストを抑えられます。

## 次のアクション
1. モノレポテンプレート（Next.js + React Native）を作成するか確認する。 
2. 簡易プロトタイプ: `POST /api/invoices`（ファイルアップロード）とOCRワーカーのスケルトンを作成。
