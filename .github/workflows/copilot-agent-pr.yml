name: Copilot Agent (OpenAI + PR)

on:
  issue_comment:
    types: [created]
  issues:
    types: [labeled]
  workflow_dispatch:
    inputs:
      issue_number:
        description: Issue number to process
        required: true
        type: string

jobs:
  agent:
    if: (github.event_name == 'issue_comment' && contains(github.event.comment.body, '@copilot') && !contains(github.event.comment.body, '@copilot merge')) || (github.event_name == 'issues' && github.event.label.name == 'copilot-ready') || (github.event_name == 'workflow_dispatch')
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Resolve issue number
        id: issue
        uses: actions/github-script@v7
        with:
          script: |
            const number = context.eventName === 'workflow_dispatch'
              ? Number(context.payload.inputs.issue_number)
              : context.issue.number;
            core.setOutput('number', String(number));
            core.exportVariable('ISSUE_NUMBER', String(number));

      - name: Prepare branch
        run: |
          BRANCH=copilot/issue-${{ steps.issue.outputs.number }}
          echo "BRANCH=$BRANCH" >> "$GITHUB_ENV"
          git checkout -B "$BRANCH"

      - name: Ensure issue is copilot-ready
        id: ready
        uses: actions/github-script@v7
        with:
          script: |
            const issueNumber = Number(process.env.ISSUE_NUMBER);
            const issue = await github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber
            }).then(res => res.data);
            const labels = (issue.labels || []).map(label => label.name);
            const ready = labels.includes('copilot-ready');
            const responded = labels.includes('copilot-responded');
            const isManual = context.eventName === 'issue_comment';
            const allowed = !isManual || responded;

            core.setOutput('ready', ready ? 'true' : 'false');
            core.setOutput('allowed', allowed ? 'true' : 'false');

            if (!ready) {
              core.info('Issue に copilot-ready が付いていないため、実行をスキップします。');
            }
            if (!allowed) {
              core.info('AI 応答前の手動 @copilot は受け付けません。');
            }

      - name: Mark copilot running
        if: steps.ready.outputs.ready == 'true' && steps.ready.outputs.allowed == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const issueNumber = Number(process.env.ISSUE_NUMBER);
            await github.rest.issues.addLabels({
              owner,
              repo,
              issue_number: issueNumber,
              labels: ['copilot-running']
            });

      - name: Build search snippets
        if: steps.ready.outputs.ready == 'true' && steps.ready.outputs.allowed == 'true'
        run: |
          python3 <<'PY'
          import json
          import os
          import re
          event_path = os.environ.get("GITHUB_EVENT_PATH")
          data = {}
          if event_path and os.path.exists(event_path):
            with open(event_path, "r", encoding="utf-8") as f:
              data = json.load(f)
          issue = data.get("issue") or {}
          text = f"{issue.get('title','')}\n{issue.get('body','')}"
          # extract simple keywords (alnum + -/_)
          tokens = re.findall(r"[A-Za-z0-9_./-]{4,}", text)
          # drop common noise
          stop = {"http", "https", "www", "com", "html", "json", "true", "false"}
          keywords = [t for t in tokens if t.lower() not in stop][:20]
          with open(".github/issue-keywords.txt", "w", encoding="utf-8") as f:
            f.write("\n".join(dict.fromkeys(keywords)))
          PY

          : > .github/agent-context.txt
          if [ ! -s .github/issue-keywords.txt ]; then
            exit 0
          fi
          rg --files -g '!node_modules/*' -g '!.next/*' -g '!**/*.log' apps/web > /tmp/all_files.txt
          : > /tmp/matched_files.txt
          while IFS= read -r kw; do
            if [ -z "$kw" ]; then continue; fi
            rg -n -S --files-with-matches -g '!node_modules/*' -g '!.next/*' -g '!**/*.log' "$kw" apps/web >> /tmp/matched_files.txt || true
          done < .github/issue-keywords.txt
          sort -u /tmp/matched_files.txt | head -n 8 > /tmp/top_files.txt
          echo "[Auto Snippets]" >> .github/agent-context.txt
          while IFS= read -r file; do
            if [ -z "$file" ]; then continue; fi
            echo "" >> .github/agent-context.txt
            echo "[$file]" >> .github/agent-context.txt
            sed -n '1,200p' "$file" >> .github/agent-context.txt
          done < /tmp/top_files.txt

      - name: Build conversation prompt
        if: steps.ready.outputs.ready == 'true' && steps.ready.outputs.allowed == 'true'
        id: prompt
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            const readFile = (filePath) => {
              try {
                return fs.readFileSync(path.join(process.env.GITHUB_WORKSPACE, filePath), 'utf-8');
              } catch {
                return '';
              }
            };

            const readTree = (dir, maxDepth = 2) => {
              const base = path.join(process.env.GITHUB_WORKSPACE, dir);
              const walk = (current, depth) => {
                if (depth > maxDepth) return [];
                let entries = [];
                try {
                  const items = fs.readdirSync(current, { withFileTypes: true });
                  for (const item of items) {
                    if (item.name.startsWith('.') || item.name === 'node_modules') continue;
                    const full = path.join(current, item.name);
                    const rel = path.relative(base, full);
                    entries.push(`${'  '.repeat(depth)}- ${rel}${item.isDirectory() ? '/' : ''}`);
                    if (item.isDirectory()) {
                      entries = entries.concat(walk(full, depth + 1));
                    }
                  }
                } catch {
                  return entries;
                }
                return entries;
              };
              return walk(base, 0).join('\n');
            };

            const issueNumber = Number(process.env.ISSUE_NUMBER);
            const issue = await github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber
            });

            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber
            });

            const architecture = readFile('apps/web/docs/architecture.md');
            const onboarding = readFile('apps/web/docs/onboarding.md');
            const webTree = readTree('apps/web', 2);
            const autoContext = readFile('.github/agent-context.txt');

            let prompt = "[Repository Context]\n";
            prompt += architecture ? `${architecture}\n\n` : "No architecture doc found.\n\n";
            prompt += onboarding ? `${onboarding}\n\n` : "No onboarding doc found.\n\n";
            prompt += "[apps/web tree]\n";
            prompt += `${webTree}\n\n`;
            if (autoContext) {
              prompt += "[Auto Snippets]\n";
              prompt += `${autoContext}\n\n`;
            }
            prompt += "[Issue Description]\n";
            prompt += issue.data.title + "\n\n";
            prompt += (issue.data.body || "") + "\n\n";
            prompt += "[Recent Conversation]\n";

            comments.data.slice(-10).forEach(c => {
              if (c.body.includes("@copilot")) {
                prompt += "User: " + c.body + "\n";
              }
              if (c.user.type === "Bot" && c.body.includes("Copilot Agent")) {
                prompt += "Agent: " + c.body + "\n";
              }
            });

            const currentInstruction = context.payload.comment?.body || '';
            prompt += "\n[Current Instruction]\n";
            prompt += currentInstruction;

            core.setOutput("prompt", prompt);

      - name: Run Inline Agent (OpenAI)
        if: steps.ready.outputs.ready == 'true' && steps.ready.outputs.allowed == 'true'
        env:
          AGENT_PROMPT: ${{ steps.prompt.outputs.prompt }}
          AZURE_OPENAI_ENDPOINT: ${{ secrets.AZURE_OPENAI_ENDPOINT }}
          AZURE_OPENAI_API_KEY: ${{ secrets.AZURE_OPENAI_API_KEY }}
          AZURE_OPENAI_API_VERSION: ${{ secrets.AZURE_OPENAI_API_VERSION }}
          AZURE_OPENAI_DEPLOYMENT: ${{ secrets.AZURE_OPENAI_DEPLOYMENT }}
          OPENAI_MODEL: ${{ secrets.OPENAI_MODEL }}
          BRANCH: ${{ env.BRANCH }}
          ISSUE_NUMBER: ${{ steps.issue.outputs.number }}
        run: |
          node <<'EOF'
          const fs = require('fs');
          const path = require('path');
          const { execSync } = require('child_process');

          const prompt = process.env.AGENT_PROMPT || 'Apply a minimal code change.';
          const branch = process.env.BRANCH;
          const issueNumber = process.env.ISSUE_NUMBER;
          const endpoint = process.env.AZURE_OPENAI_ENDPOINT;
          const apiKey = process.env.AZURE_OPENAI_API_KEY;
          const apiVersion = process.env.AZURE_OPENAI_API_VERSION;
          const deployment = process.env.AZURE_OPENAI_DEPLOYMENT;
          const model = process.env.OPENAI_MODEL;

          const envFile = process.env.GITHUB_ENV;
          const setEnv = (key, value) => {
            if (!envFile) return;
            fs.appendFileSync(envFile, `${key}=${value}\n`);
          };

          (async () => {
            try {
              if (!endpoint || !apiKey || !apiVersion || !deployment) {
                const message = [
                  'Azure OpenAI の設定が不足しています。',
                  'AZURE_OPENAI_ENDPOINT / AZURE_OPENAI_API_KEY / AZURE_OPENAI_API_VERSION / AZURE_OPENAI_DEPLOYMENT を設定してください。',
                  '設定後、もう一度 @copilot をメンションしてください。'
                ].join('\n');
                const responsePath = path.join(process.cwd(), 'agent-response.txt');
                fs.writeFileSync(responsePath, message, 'utf-8');
                setEnv('CHANGED', 'false');
                setEnv('RESPONSE_TYPE', 'quota');
                return;
              }

              const url = `${endpoint.replace(/\/$/, '')}/openai/deployments/${deployment}/chat/completions?api-version=${apiVersion}`;
              const payload = {
                messages: [
                  { role: 'system', content: 'You are a coding agent for this repository. If you can implement the fix, output a single JSON object only (no code fences). Schema: {"summary":"...", "files":[{"path":"relative/path.ext","content":"FULL FILE CONTENT"}]}. Include full contents for each modified file. If requirements are unclear, ask concise clarifying questions in Japanese as plain text (not JSON).' },
                  { role: 'user', content: prompt }
                ],
                max_completion_tokens: 3000
              };
              if (model) payload.model = model;

              const res = await fetch(url, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'api-key': apiKey
                },
                body: JSON.stringify(payload)
              });

              if (!res.ok) {
                const body = await res.text();
                const error = new Error(`Azure OpenAI request failed: ${res.status} ${body}`);
                error.status = res.status;
                throw error;
              }

              const callModel = async (extraInstruction = '') => {
                const res = await fetch(url, {
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json',
                    'api-key': apiKey
                  },
                  body: JSON.stringify({
                    ...payload,
                    messages: [
                      ...payload.messages,
                      ...(extraInstruction ? [{ role: 'system', content: extraInstruction }] : [])
                    ]
                  })
                });
                if (!res.ok) {
                  const body = await res.text();
                  const error = new Error(`Azure OpenAI request failed: ${res.status} ${body}`);
                  error.status = res.status;
                  throw error;
                }
                return res.json();
              };

              const extractJson = (text) => {
                const trimmed = (text || '').trim();
                if (!trimmed) return null;
                if (trimmed.startsWith('{')) {
                  try { return JSON.parse(trimmed); } catch {}
                }
                const match = trimmed.match(/\{[\s\S]*\}/);
                if (match) {
                  try { return JSON.parse(match[0]); } catch {}
                }
                return null;
              };

              const data = await callModel();
              let output = (data.choices?.[0]?.message?.content || '').trim();
              if (!output) {
                throw new Error('Model returned empty output.');
              }

              const responsePath = path.join(process.cwd(), 'agent-response.txt');
              fs.writeFileSync(responsePath, output, 'utf-8');

              let json = extractJson(output);
              if (!json && output.startsWith('{')) {
                const retry = await callModel('Output a valid JSON object only. Do not include explanations or code fences.');
                output = (retry.choices?.[0]?.message?.content || '').trim();
                fs.writeFileSync(responsePath, output, 'utf-8');
                json = extractJson(output);
              }

              if (!json || !Array.isArray(json.files)) {
                setEnv('CHANGED', 'false');
                setEnv('RESPONSE_TYPE', 'question');
                return;
              }

              const repoRoot = process.cwd();
              for (const file of json.files) {
                if (!file?.path || typeof file.content !== 'string') {
                  continue;
                }
                const relPath = file.path.replace(/^\/+/, '');
                if (relPath.includes('..')) {
                  throw new Error(`Invalid path: ${file.path}`);
                }
                const absPath = path.resolve(repoRoot, relPath);
                if (!absPath.startsWith(repoRoot)) {
                  throw new Error(`Path outside repo: ${file.path}`);
                }
                fs.mkdirSync(path.dirname(absPath), { recursive: true });
                fs.writeFileSync(absPath, file.content, 'utf-8');
              }

              execSync('git config user.name "Copilot Agent"');
              execSync('git config user.email "copilot-agent@github.com"');
              execSync('git add -A');

              const staged = execSync('git diff --cached --name-only').toString().trim();
              if (!staged) {
                console.log('変更が検出されませんでした。');
                setEnv('CHANGED', 'false');
                return;
              }

              execSync('git commit -m "Copilot Agent: apply issue changes"');
              execSync(`git push origin ${branch} --force`);

              setEnv('CHANGED', 'true');
              setEnv('RESPONSE_TYPE', 'patch');
              console.log('Changes pushed to branch:', branch);
            } catch (err) {
              const status = err?.status;
              const code = err?.error?.code;
              if (status === 429 || code === 'insufficient_quota') {
                const message = [
                  'OpenAI API の利用上限に達したため処理を続行できません。',
                  '管理者に連絡して API の課金・上限設定を確認してください。',
                  '上限が回復したら、もう一度 @copilot をメンションしてください。'
                ].join('\n');
                const responsePath = path.join(process.cwd(), 'agent-response.txt');
                fs.writeFileSync(responsePath, message, 'utf-8');
                setEnv('CHANGED', 'false');
                setEnv('RESPONSE_TYPE', 'quota');
                return;
              }
              console.error('Agent run failed:', err);
              process.exit(1);
            }
          })();
          EOF

      - name: Run web tests
        if: env.CHANGED == 'true' && steps.ready.outputs.allowed == 'true'
        env:
          CI: true
        run: |
          set +e
          cd apps/web
          if [ -f .env.example ] && [ ! -f .env.local ]; then
            cp .env.example .env.local
          fi
          npm install --no-audit --no-fund
          npm run lint > ../../agent-test-report.txt 2>&1
          LINT_STATUS=$?
          npm run build >> ../../agent-test-report.txt 2>&1
          BUILD_STATUS=$?
          npx playwright install --with-deps >> ../../agent-test-report.txt 2>&1
          npm run test:e2e >> ../../agent-test-report.txt 2>&1
          E2E_STATUS=$?
          echo "lint=$LINT_STATUS build=$BUILD_STATUS e2e=$E2E_STATUS" >> ../../agent-test-report.txt
          if [ $LINT_STATUS -ne 0 ] || [ $BUILD_STATUS -ne 0 ] || [ $E2E_STATUS -ne 0 ]; then
            echo "TEST_STATUS=failed" >> $GITHUB_ENV
          else
            echo "TEST_STATUS=passed" >> $GITHUB_ENV
          fi
          exit 0

      - name: Publish test report html
        if: env.CHANGED == 'true' && steps.ready.outputs.allowed == 'true'
        run: |
          node <<'EOF'
          const fs = require('fs');
          const path = require('path');

          const reportPath = path.join(process.cwd(), 'agent-test-report.txt');
          const report = fs.existsSync(reportPath) ? fs.readFileSync(reportPath, 'utf-8') : 'No test report found.';
          const html = `<!doctype html>
          <html lang="en">
            <head>
              <meta charset="utf-8" />
              <meta name="viewport" content="width=device-width, initial-scale=1" />
              <title>Agent Test Report</title>
              <style>
                :root { color-scheme: light; }
                body { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; margin: 32px; line-height: 1.5; }
                pre { background: #f7f7f7; padding: 16px; border-radius: 8px; overflow: auto; }
              </style>
            </head>
            <body>
              <h1>Agent Test Report</h1>
              <pre>${report.replace(/[&<>]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;'}[c]))}</pre>
            </body>
          </html>`;
          fs.mkdirSync(path.join(process.cwd(), 'docs'), { recursive: true });
          fs.writeFileSync(path.join(process.cwd(), 'docs', 'index.html'), html, 'utf-8');
          EOF
          git add docs/index.html agent-test-report.txt

      - name: Post test questions
        if: env.CHANGED == 'true' && env.TEST_STATUS == 'failed' && steps.ready.outputs.allowed == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const issueNumber = Number(process.env.ISSUE_NUMBER);
            const reportPath = `${process.env.GITHUB_WORKSPACE}/agent-test-report.txt`;
            const report = fs.existsSync(reportPath) ? fs.readFileSync(reportPath, 'utf-8') : 'No test report found.';
            const lines = report.split('\n').slice(-80).join('\n');
            const questions = [
              'Which environment variables are required for apps/web build and E2E?',
              'Do we need to seed a database or use a mock for E2E?',
              'Is there a preferred base URL or port for tests in CI?',
              'Should failing tests be skipped or retried in CI?'
            ];

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              body: [
                'テストが失敗しました。続行する前に確認が必要です:',
                '',
                ...questions.map(q => `- ${q}`),
                '',
                'Recent test output:',
                '```',
                lines,
                '```'
              ].join('\n')
            });

      - name: Create or Update Pull Request
        if: env.CHANGED == 'true' && steps.ready.outputs.allowed == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const { owner, repo } = context.repo;
            const branch = process.env.BRANCH;
            const head = `${owner}:${branch}`;
            const reportPath = `${process.env.GITHUB_WORKSPACE}/agent-test-report.txt`;
            const report = fs.existsSync(reportPath) ? fs.readFileSync(reportPath, 'utf-8') : 'No test report found.';
            const reportBlock = `\n\n## Test Report\n\n\`\`\`\n${report}\n\`\`\`\n`;

            const prs = await github.rest.pulls.list({
              owner,
              repo,
              head,
              state: 'open'
            });

            if (prs.data.length > 0) {
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: prs.data[0].number,
                body: reportBlock
              });
              return;
            }

            await github.rest.pulls.create({
              owner,
              repo,
              title: 'Copilot Agent PR',
              head: branch,
              base: 'main',
              body: 'Agent completed one iteration. Review and reply `@copilot merge`.' + reportBlock
            });

      - name: Reply to issue
        if: steps.ready.outputs.ready == 'true' && steps.ready.outputs.allowed == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const issueNumber = Number(process.env.ISSUE_NUMBER);
            const responsePath = `${process.env.GITHUB_WORKSPACE}/agent-response.txt`;
            const responseText = fs.existsSync(responsePath) ? fs.readFileSync(responsePath, 'utf-8') : '';
            const responseType = process.env.RESPONSE_TYPE;
            const isQuestion = responseType === 'question' && responseText.trim().length > 0;
            const isQuota = responseType === 'quota' && responseText.trim().length > 0;

            const message = (isQuestion || isQuota)
              ? responseText
              : (process.env.CHANGED == 'true'
                ? '変更が用意できました。copilot ブランチから PR を作成しました。'
                : '変更が生成されませんでした。もう一度試す場合は依頼内容を具体化してください。');

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              body: message
            });

      - name: Mark copilot responded
        if: steps.ready.outputs.ready == 'true' && steps.ready.outputs.allowed == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const issueNumber = Number(process.env.ISSUE_NUMBER);
            await github.rest.issues.addLabels({
              owner,
              repo,
              issue_number: issueNumber,
              labels: ['copilot-responded']
            });

      - name: Clear copilot running
        if: steps.ready.outputs.ready == 'true' && steps.ready.outputs.allowed == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const issueNumber = Number(process.env.ISSUE_NUMBER);
            try {
              await github.rest.issues.removeLabel({
                owner,
                repo,
                issue_number: issueNumber,
                name: 'copilot-running'
              });
            } catch (err) {
              if (err.status !== 404) throw err;
            }

  auto-merge:
    if: contains(github.event.comment.body, '@copilot merge')
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      contents: write
      issues: write
    steps:
      - uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const head = `${owner}:copilot/issue-${context.issue.number}`;

            const prs = await github.rest.pulls.list({
              owner,
              repo,
              head,
              state: 'open'
            });

            if (!prs.data.length) {
              core.info('No open PR to merge.');
              return;
            }

            await github.rest.pulls.merge({
              owner,
              repo,
              pull_number: prs.data[0].number,
              merge_method: 'squash'
            });
