name: Copilot Agent (OpenAI + PR)

on:
  issue_comment:
    types: [created]
  issues:
    types: [labeled]
  workflow_dispatch:
    inputs:
      issue_number:
        description: Issue number to process
        required: true
        type: string

jobs:
  agent:
    if: (github.event_name == 'issue_comment' && contains(github.event.comment.body, '@copilot') && !contains(github.event.comment.body, '@copilot merge')) || (github.event_name == 'issues' && github.event.label.name == 'copilot-ready') || (github.event_name == 'workflow_dispatch')
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Resolve issue number
        id: issue
        uses: actions/github-script@v7
        with:
          script: |
            const number = context.eventName === 'workflow_dispatch'
              ? Number(context.payload.inputs.issue_number)
              : context.issue.number;
            core.setOutput('number', String(number));
            core.exportVariable('ISSUE_NUMBER', String(number));

      - name: Prepare branch
        run: |
          BRANCH=copilot/issue-${{ steps.issue.outputs.number }}
          echo "BRANCH=$BRANCH" >> "$GITHUB_ENV"
          git checkout -B "$BRANCH"

      - name: Ensure issue is copilot-ready
        id: ready
        uses: actions/github-script@v7
        with:
          script: |
            const issueNumber = Number(process.env.ISSUE_NUMBER);
            const issue = await github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber
            }).then(res => res.data);
            const labels = (issue.labels || []).map(label => label.name);
            const ready = labels.includes('copilot-ready');
            const responded = labels.includes('copilot-responded');
            const isManual = context.eventName === 'issue_comment';
            const allowed = !isManual || responded;

            core.setOutput('ready', ready ? 'true' : 'false');
            core.setOutput('allowed', allowed ? 'true' : 'false');

            if (!ready) {
              core.info('Issue に copilot-ready が付いていないため、実行をスキップします。');
            }
            if (!allowed) {
              core.info('AI 応答前の手動 @copilot は受け付けません。');
            }

      - name: Mark copilot running
        if: steps.ready.outputs.ready == 'true' && steps.ready.outputs.allowed == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const issueNumber = Number(process.env.ISSUE_NUMBER);
            await github.rest.issues.addLabels({
              owner,
              repo,
              issue_number: issueNumber,
              labels: ['copilot-running']
            });

      - name: Build conversation prompt
        if: steps.ready.outputs.ready == 'true' && steps.ready.outputs.allowed == 'true'
        id: prompt
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            const readFile = (filePath) => {
              try {
                return fs.readFileSync(path.join(process.env.GITHUB_WORKSPACE, filePath), 'utf-8');
              } catch {
                return '';
              }
            };

            const readTree = (dir, maxDepth = 2) => {
              const base = path.join(process.env.GITHUB_WORKSPACE, dir);
              const walk = (current, depth) => {
                if (depth > maxDepth) return [];
                let entries = [];
                try {
                  const items = fs.readdirSync(current, { withFileTypes: true });
                  for (const item of items) {
                    if (item.name.startsWith('.') || item.name === 'node_modules') continue;
                    const full = path.join(current, item.name);
                    const rel = path.relative(base, full);
                    entries.push(`${'  '.repeat(depth)}- ${rel}${item.isDirectory() ? '/' : ''}`);
                    if (item.isDirectory()) {
                      entries = entries.concat(walk(full, depth + 1));
                    }
                  }
                } catch {
                  return entries;
                }
                return entries;
              };
              return walk(base, 0).join('\n');
            };

            const issueNumber = Number(process.env.ISSUE_NUMBER);
            const issue = await github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber
            });

            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber
            });

            const architecture = readFile('apps/web/docs/architecture.md');
            const onboarding = readFile('apps/web/docs/onboarding.md');
            const webTree = readTree('apps/web', 2);

            let prompt = "[Repository Context]\n";
            prompt += architecture ? `${architecture}\n\n` : "No architecture doc found.\n\n";
            prompt += onboarding ? `${onboarding}\n\n` : "No onboarding doc found.\n\n";
            prompt += "[apps/web tree]\n";
            prompt += `${webTree}\n\n`;
            prompt += "[Issue Description]\n";
            prompt += issue.data.title + "\n\n";
            prompt += (issue.data.body || "") + "\n\n";
            prompt += "[Recent Conversation]\n";

            comments.data.slice(-10).forEach(c => {
              if (c.body.includes("@copilot")) {
                prompt += "User: " + c.body + "\n";
              }
              if (c.user.type === "Bot" && c.body.includes("Copilot Agent")) {
                prompt += "Agent: " + c.body + "\n";
              }
            });

            const currentInstruction = context.payload.comment?.body || '';
            prompt += "\n[Current Instruction]\n";
            prompt += currentInstruction;

            core.setOutput("prompt", prompt);

      - name: Run Inline Agent (OpenAI)
        if: steps.ready.outputs.ready == 'true' && steps.ready.outputs.allowed == 'true'
        env:
          AGENT_PROMPT: ${{ steps.prompt.outputs.prompt }}
          AZURE_OPENAI_ENDPOINT: ${{ secrets.AZURE_OPENAI_ENDPOINT }}
          AZURE_OPENAI_API_KEY: ${{ secrets.AZURE_OPENAI_API_KEY }}
          AZURE_OPENAI_API_VERSION: ${{ secrets.AZURE_OPENAI_API_VERSION }}
          AZURE_OPENAI_DEPLOYMENT: ${{ secrets.AZURE_OPENAI_DEPLOYMENT }}
          OPENAI_MODEL: ${{ secrets.OPENAI_MODEL }}
          BRANCH: ${{ env.BRANCH }}
          ISSUE_NUMBER: ${{ steps.issue.outputs.number }}
        run: |
          node <<'EOF'
          const fs = require('fs');
          const path = require('path');
          const { execSync } = require('child_process');

          const prompt = process.env.AGENT_PROMPT || 'Apply a minimal code change.';
          const branch = process.env.BRANCH;
          const issueNumber = process.env.ISSUE_NUMBER;
          const endpoint = process.env.AZURE_OPENAI_ENDPOINT;
          const apiKey = process.env.AZURE_OPENAI_API_KEY;
          const apiVersion = process.env.AZURE_OPENAI_API_VERSION;
          const deployment = process.env.AZURE_OPENAI_DEPLOYMENT;
          const model = process.env.OPENAI_MODEL;

          const envFile = process.env.GITHUB_ENV;
          const setEnv = (key, value) => {
            if (!envFile) return;
            fs.appendFileSync(envFile, `${key}=${value}\n`);
          };

          (async () => {
            try {
              if (!endpoint || !apiKey || !apiVersion || !deployment) {
                const message = [
                  'Azure OpenAI の設定が不足しています。',
                  'AZURE_OPENAI_ENDPOINT / AZURE_OPENAI_API_KEY / AZURE_OPENAI_API_VERSION / AZURE_OPENAI_DEPLOYMENT を設定してください。',
                  '設定後、もう一度 @copilot をメンションしてください。'
                ].join('\n');
                const responsePath = path.join(process.cwd(), 'agent-response.txt');
                fs.writeFileSync(responsePath, message, 'utf-8');
                setEnv('CHANGED', 'false');
                setEnv('RESPONSE_TYPE', 'quota');
                return;
              }

              const url = `${endpoint.replace(/\/$/, '')}/openai/deployments/${deployment}/chat/completions?api-version=${apiVersion}`;
              const payload = {
                messages: [
                  { role: 'system', content: 'You are a coding agent for this repository. If you can implement the fix, output a unified diff patch only. If requirements are unclear, ask concise clarifying questions in Japanese, without code fences.' },
                  { role: 'user', content: prompt }
                ],
                max_completion_tokens: 3000
              };
              if (model) payload.model = model;

              const res = await fetch(url, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'api-key': apiKey
                },
                body: JSON.stringify(payload)
              });

              if (!res.ok) {
                const body = await res.text();
                const error = new Error(`Azure OpenAI request failed: ${res.status} ${body}`);
                error.status = res.status;
                throw error;
              }

              const callModel = async (extraInstruction = '') => {
                const res = await fetch(url, {
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json',
                    'api-key': apiKey
                  },
                  body: JSON.stringify({
                    ...payload,
                    messages: [
                      ...payload.messages,
                      ...(extraInstruction ? [{ role: 'system', content: extraInstruction }] : [])
                    ]
                  })
                });
                if (!res.ok) {
                  const body = await res.text();
                  const error = new Error(`Azure OpenAI request failed: ${res.status} ${body}`);
                  error.status = res.status;
                  throw error;
                }
                return res.json();
              };

              const normalize = (content) => {
                let output = (content || '').trim();
                const fenced = output.match(/```(?:diff|patch)?\s*([\s\S]*?)```/i);
                if (fenced && fenced[1]) {
                  output = fenced[1].trim();
                }
                const diffIndex = output.indexOf('diff --git');
                if (diffIndex !== -1) {
                  output = output.slice(diffIndex).trim();
                }
                return output;
              };

              const data = await callModel();
              let output = normalize(data.choices?.[0]?.message?.content || '');
              if (!output) {
                throw new Error('Model returned empty output.');
              }

              const responsePath = path.join(process.cwd(), 'agent-response.txt');
              fs.writeFileSync(responsePath, output, 'utf-8');

              const tryApply = (patchText) => {
                const patchPath = path.join(process.cwd(), 'agent.patch');
                fs.writeFileSync(patchPath, patchText, 'utf-8');
                execSync(`git apply --check ${patchPath}`);
                execSync(`git apply --whitespace=fix ${patchPath}`);
              };

              let applied = false;
              if (output.startsWith('diff --git')) {
                try {
                  tryApply(output);
                  applied = true;
                } catch {
                  applied = false;
                }
              }

              if (!applied) {
                const retry = await callModel('Output a valid unified diff only. It must start with "diff --git". Do not include explanations or code fences.');
                output = normalize(retry.choices?.[0]?.message?.content || '');
                fs.writeFileSync(responsePath, output, 'utf-8');
                if (output.startsWith('diff --git')) {
                  try {
                    tryApply(output);
                    applied = true;
                  } catch {
                    applied = false;
                  }
                }
              }

              if (!applied) {
                const message = [
                  '生成された差分に問題があり、適用できませんでした。',
                  '自動再試行でも修復できなかったため、内容を少し詳しく書いて再度 @copilot をメンションしてください。'
                ].join('\n');
                fs.writeFileSync(responsePath, message, 'utf-8');
                setEnv('CHANGED', 'false');
                setEnv('RESPONSE_TYPE', 'question');
                return;
              }

              execSync('git config user.name "Copilot Agent"');
              execSync('git config user.email "copilot-agent@github.com"');
              execSync('git add -A');

              const staged = execSync('git diff --cached --name-only').toString().trim();
              if (!staged) {
                console.log('変更が検出されませんでした。');
                setEnv('CHANGED', 'false');
                return;
              }

              execSync('git commit -m "Copilot Agent: apply issue changes"');
              execSync(`git push origin ${branch} --force`);

              setEnv('CHANGED', 'true');
              setEnv('RESPONSE_TYPE', 'patch');
              console.log('Changes pushed to branch:', branch);
            } catch (err) {
              const status = err?.status;
              const code = err?.error?.code;
              if (status === 429 || code === 'insufficient_quota') {
                const message = [
                  'OpenAI API の利用上限に達したため処理を続行できません。',
                  '管理者に連絡して API の課金・上限設定を確認してください。',
                  '上限が回復したら、もう一度 @copilot をメンションしてください。'
                ].join('\n');
                const responsePath = path.join(process.cwd(), 'agent-response.txt');
                fs.writeFileSync(responsePath, message, 'utf-8');
                setEnv('CHANGED', 'false');
                setEnv('RESPONSE_TYPE', 'quota');
                return;
              }
              console.error('Agent run failed:', err);
              process.exit(1);
            }
          })();
          EOF

      - name: Run web tests
        if: env.CHANGED == 'true' && steps.ready.outputs.allowed == 'true'
        env:
          CI: true
        run: |
          set +e
          cd apps/web
          if [ -f .env.example ] && [ ! -f .env.local ]; then
            cp .env.example .env.local
          fi
          npm install --no-audit --no-fund
          npm run lint > ../../agent-test-report.txt 2>&1
          LINT_STATUS=$?
          npm run build >> ../../agent-test-report.txt 2>&1
          BUILD_STATUS=$?
          npx playwright install --with-deps >> ../../agent-test-report.txt 2>&1
          npm run test:e2e >> ../../agent-test-report.txt 2>&1
          E2E_STATUS=$?
          echo "lint=$LINT_STATUS build=$BUILD_STATUS e2e=$E2E_STATUS" >> ../../agent-test-report.txt
          if [ $LINT_STATUS -ne 0 ] || [ $BUILD_STATUS -ne 0 ] || [ $E2E_STATUS -ne 0 ]; then
            echo "TEST_STATUS=failed" >> $GITHUB_ENV
          else
            echo "TEST_STATUS=passed" >> $GITHUB_ENV
          fi
          exit 0

      - name: Publish test report html
        if: env.CHANGED == 'true' && steps.ready.outputs.allowed == 'true'
        run: |
          node <<'EOF'
          const fs = require('fs');
          const path = require('path');

          const reportPath = path.join(process.cwd(), 'agent-test-report.txt');
          const report = fs.existsSync(reportPath) ? fs.readFileSync(reportPath, 'utf-8') : 'No test report found.';
          const html = `<!doctype html>
          <html lang="en">
            <head>
              <meta charset="utf-8" />
              <meta name="viewport" content="width=device-width, initial-scale=1" />
              <title>Agent Test Report</title>
              <style>
                :root { color-scheme: light; }
                body { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; margin: 32px; line-height: 1.5; }
                pre { background: #f7f7f7; padding: 16px; border-radius: 8px; overflow: auto; }
              </style>
            </head>
            <body>
              <h1>Agent Test Report</h1>
              <pre>${report.replace(/[&<>]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;'}[c]))}</pre>
            </body>
          </html>`;
          fs.mkdirSync(path.join(process.cwd(), 'docs'), { recursive: true });
          fs.writeFileSync(path.join(process.cwd(), 'docs', 'index.html'), html, 'utf-8');
          EOF
          git add docs/index.html agent-test-report.txt

      - name: Post test questions
        if: env.CHANGED == 'true' && env.TEST_STATUS == 'failed' && steps.ready.outputs.allowed == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const issueNumber = Number(process.env.ISSUE_NUMBER);
            const reportPath = `${process.env.GITHUB_WORKSPACE}/agent-test-report.txt`;
            const report = fs.existsSync(reportPath) ? fs.readFileSync(reportPath, 'utf-8') : 'No test report found.';
            const lines = report.split('\n').slice(-80).join('\n');
            const questions = [
              'Which environment variables are required for apps/web build and E2E?',
              'Do we need to seed a database or use a mock for E2E?',
              'Is there a preferred base URL or port for tests in CI?',
              'Should failing tests be skipped or retried in CI?'
            ];

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              body: [
                'テストが失敗しました。続行する前に確認が必要です:',
                '',
                ...questions.map(q => `- ${q}`),
                '',
                'Recent test output:',
                '```',
                lines,
                '```'
              ].join('\n')
            });

      - name: Create or Update Pull Request
        if: env.CHANGED == 'true' && steps.ready.outputs.allowed == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const { owner, repo } = context.repo;
            const branch = process.env.BRANCH;
            const head = `${owner}:${branch}`;
            const reportPath = `${process.env.GITHUB_WORKSPACE}/agent-test-report.txt`;
            const report = fs.existsSync(reportPath) ? fs.readFileSync(reportPath, 'utf-8') : 'No test report found.';
            const reportBlock = `\n\n## Test Report\n\n\`\`\`\n${report}\n\`\`\`\n`;

            const prs = await github.rest.pulls.list({
              owner,
              repo,
              head,
              state: 'open'
            });

            if (prs.data.length > 0) {
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: prs.data[0].number,
                body: reportBlock
              });
              return;
            }

            await github.rest.pulls.create({
              owner,
              repo,
              title: 'Copilot Agent PR',
              head: branch,
              base: 'main',
              body: 'Agent completed one iteration. Review and reply `@copilot merge`.' + reportBlock
            });

      - name: Reply to issue
        if: steps.ready.outputs.ready == 'true' && steps.ready.outputs.allowed == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const issueNumber = Number(process.env.ISSUE_NUMBER);
            const responsePath = `${process.env.GITHUB_WORKSPACE}/agent-response.txt`;
            const responseText = fs.existsSync(responsePath) ? fs.readFileSync(responsePath, 'utf-8') : '';
            const responseType = process.env.RESPONSE_TYPE;
            const isQuestion = responseType === 'question' && responseText.trim().length > 0;
            const isQuota = responseType === 'quota' && responseText.trim().length > 0;

            const message = (isQuestion || isQuota)
              ? responseText
              : (process.env.CHANGED == 'true'
                ? '変更が用意できました。copilot ブランチから PR を作成しました。'
                : '変更が生成されませんでした。もう一度試す場合は依頼内容を具体化してください。');

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              body: message
            });

      - name: Mark copilot responded
        if: steps.ready.outputs.ready == 'true' && steps.ready.outputs.allowed == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const issueNumber = Number(process.env.ISSUE_NUMBER);
            await github.rest.issues.addLabels({
              owner,
              repo,
              issue_number: issueNumber,
              labels: ['copilot-responded']
            });

      - name: Clear copilot running
        if: steps.ready.outputs.ready == 'true' && steps.ready.outputs.allowed == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const issueNumber = Number(process.env.ISSUE_NUMBER);
            try {
              await github.rest.issues.removeLabel({
                owner,
                repo,
                issue_number: issueNumber,
                name: 'copilot-running'
              });
            } catch (err) {
              if (err.status !== 404) throw err;
            }

  auto-merge:
    if: contains(github.event.comment.body, '@copilot merge')
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      contents: write
      issues: write
    steps:
      - uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const head = `${owner}:copilot/issue-${context.issue.number}`;

            const prs = await github.rest.pulls.list({
              owner,
              repo,
              head,
              state: 'open'
            });

            if (!prs.data.length) {
              core.info('No open PR to merge.');
              return;
            }

            await github.rest.pulls.merge({
              owner,
              repo,
              pull_number: prs.data[0].number,
              merge_method: 'squash'
            });
